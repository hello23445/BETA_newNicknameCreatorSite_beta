<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Генератор Аватарки</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * {
      user-select: none;
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #74ABE2, #5563DE);
      min-height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: manipulation;
    }
    .container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100vh;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      border-radius: 0;
      overflow: hidden;
      background: none;
      position: relative;
    }
    .preview {
      flex: 1;
      background: none;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      touch-action: none;
    }
    #avatarCanvas {
      max-width: 100%;
      max-height: 100%;
      width: 100vw;
      height: 50vh;
      border: 1px solid #ccc;
      background: transparent;
      touch-action: none;
    }
    #dragOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 4vw;
      font-weight: bold;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .tools {
      width: 100%;
      height: 50vh;
      padding: 3vw;
      overflow-y: auto;
      background: #c6ddff;
      position: relative;
      transition: all 0.3s ease;
    }
    #hideToolsButton, #openToolsButton, #shareTelegramBtn {
      display: block;
      margin: 2vw 0;
      padding: 2.5vw 3vw;
      background: red;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-size: 4vw;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      touch-action: manipulation;
      transition: background 0.2s;
    }
    #hideToolsButton:hover, #openToolsButton:hover, #shareTelegramBtn:hover {
      background: darkred;
    }
    #shareTelegramBtn {
      background: #0088cc;
    }
    #shareTelegramBtn:hover {
      background: #006699;
    }
    .tools label {
      display: block;
      margin-top: 3vw;
      font-weight: bold;
      font-size: 4vw;
    }
    .tools input[type="range"],
    .tools select,
    .tools input[type="color"],
    .tools input[type="file"],
    .tools textarea {
      width: 100%;
      margin-top: 1vw;
      padding: 2vw;
      font-size: 4vw;
      box-sizing: border-box;
    }
    .btn-remove {
      display: inline-block;
      margin-top: 2vw;
      padding: 2vw;
      background: red;
      color: #fff;
      font-weight: bold;
      border: none;
      cursor: pointer;
      font-size: 4vw;
      transition: background 0.2s;
    }
    .btn-remove:hover {
      background: darkred;
    }
    .tools button {
      margin-top: 3vw;
      padding: 2.5vw 3vw;
      background: blue;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      font-size: 4vw;
      transition: background 0.2s;
    }
    .tools button:hover {
      background: darkblue;
    }
    .preview.dragover {
      border: 3px dashed #888;
    }
    #mediaSettings {
      margin-top: 3vw;
      padding: 2vw;
      border: 1px dashed #ccc;
      display: none;
    }
    #orientation-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    #orientation-warning div {
      background-color: rgba(50, 50, 50, 0.9);
      padding: 5vw;
      border-radius: 10px;
      text-align: center;
    }
    #orientation-warning p {
      margin: 0 0 5vw;
      color: #fff;
      font-weight: bold;
      font-size: 4vw;
    }
    #orientation-warning button {
      padding: 2.5vw 5vw;
      font-size: 4vw;
      font-weight: bold;
      cursor: pointer;
      background-color: red;
      color: white;
      border: none;
      border-radius: 5px;
      transition: background 0.2s;
    }
    #orientation-warning button:hover {
      background: darkred;
    }
    #video-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 15000;
      justify-content: center;
      align-items: center;
    }
    #video-modal div {
      background-color: rgba(50, 50, 50, 0.9);
      padding: 5vw;
      border-radius: 10px;
      text-align: center;
    }
    #video-modal p {
      margin: 0 0 5vw;
      color: #fff;
      font-weight: bold;
      font-size: 4vw;
    }
    #video-modal button {
      padding: 2.5vw 5vw;
      font-size: 4vw;
      font-weight: bold;
      cursor: pointer;
      background-color: red;
      color: white;
      border: none;
      border-radius: 5px;
      margin: 0 1vw;
      transition: background 0.2s;
    }
    #video-modal button:hover {
      background: darkred;
    }
    #openToolsButton {
      position: fixed;
      top: 2vw;
      left: 2vw;
      z-index: 9999;
      display: none;
    }
    #customShapeModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      z-index: 20000;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    #eraserSettings {
      position: absolute;
      left: 5vw;
      top: 5vw;
      background: rgba(0,0,0,0.6);
      padding: 2vw;
      border-radius: 5px;
      display: none;
      z-index: 21000;
    }
    #eraserSettings label {
      font-weight: bold;
      color: #fff;
      font-size: 4vw;
    }
    #eraserSettings input[type="range"] {
      width: 40vw;
      margin-top: 1vw;
    }
    #customShapeModal canvas {
      background: #fff;
      border: 2px solid #000;
      width: 90vw;
      height: 50vh;
    }
    #customShapeModal .modal-buttons {
      margin-top: 3vw;
      display: flex;
      gap: 2vw;
    }
    #customShapeModal button {
      padding: 2.5vw 5vw;
      background: green;
      color: #fff;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      font-size: 4vw;
      transition: background 0.2s;
    }
    #customShapeModal button:hover {
      background: darkgreen;
    }
    #customShapeModal button.cancel {
      background: red;
    }
    #customShapeModal button.cancel:hover {
      background: darkred;
    }
    @media (min-width: 600px) {
      .container {
        flex-direction: row;
        width: 90%;
        max-width: 1200px;
        height: 90vh;
        border-radius: 12px;
      }
      .preview {
        width: 60%;
        height: 100%;
      }
      .tools {
        width: 40%;
        height: 100%;
        padding: 20px;
      }
      #avatarCanvas {
        width: 100%;
        height: 100%;
      }
      #hideToolsButton, #openToolsButton, #shareTelegramBtn {
        font-size: 16px;
        padding: 10px 15px;
      }
      .tools label, .tools button, .btn-remove {
        font-size: 16px;
      }
      .tools input[type="range"],
      .tools select,
      .tools input[type="color"],
      .tools input[type="file"],
      .tools textarea {
        font-size: 16px;
        padding: 10px;
      }
      #orientation-warning p, #video-modal p {
        font-size: 16px;
      }
      #orientation-warning button, #video-modal button {
        font-size: 16px;
        padding: 10px 20px;
      }
      #eraserSettings input[type="range"] {
        width: 150px;
      }
      #customShapeModal canvas {
        width: 500px;
        height: 500px;
      }
      #customShapeModal button {
        font-size: 16px;
        padding: 10px 20px;
      }
      #dragOverlay {
        font-size: 18px;
      }
    }
    @media (max-width: 400px) {
      #avatarCanvas {
        height: 40vh;
      }
      .tools {
        height: 60vh;
        padding: 2vw;
      }
      #hideToolsButton, #openToolsButton, #shareTelegramBtn {
        font-size: 3.5vw;
        padding: 2vw 2.5vw;
      }
      .tools label {
        font-size: 3.5vw;
      }
      .tools input[type="range"],
      .tools select,
      .tools input[type="color"],
      .tools input[type="file"],
      .tools textarea {
        font-size: 3.5vw;
        padding: 1.5vw;
      }
      #customShapeModal canvas {
        width: 80vw;
        height: 40vh;
      }
    }
  </style>
</head>
<body>
  <div id="orientation-warning">
    <div>
      <p>Пожалуйста, используйте портретный режим для лучшего отображения.</p>
      <button id="orientation-ok">OK</button>
    </div>
  </div>

  <div id="video-modal">
    <div>
      <p>Видео не должно превышать 15 секунд!</p>
      <button id="video-modal-ok">OK</button>
    </div>
  </div>

  <div id="customShapeModal">
    <div id="eraserSettings">
      <label for="eraserSizeRange">Размер ластика:</label>
      <input type="range" id="eraserSizeRange" min="5" max="100" value="20" />
    </div>
    <canvas id="customShapeCanvas" width="400" height="400"></canvas>
    <div class="modal-buttons">
      <button id="toggleEraser">Ластик</button>
      <button id="resetCustomShape">Сбросить</button>
      <button id="saveCustomShape">Сохранить</button>
      <button id="cancelCustomShape" class="cancel">Отмена</button>
    </div>
  </div>

  <div class="container">
    <button id="openToolsButton"><b>ОТКРЫТЬ МЕНЮ ИНСТРУМЕНТОВ</b></button>
    <button 
      onclick="window.location.href = 'main.html'" 
      style="padding: 2.5vw 3vw; font-size: 4vw; display: none; width: 25%; height: 5vh; margin-top: 2%;"
      id="backToMainMenuButton"
    >
      ВЕРНУТЬСЯ В ГЛАВНОЕ МЕНЮ
    </button>

    <div class="preview" id="previewArea">
      <canvas id="avatarCanvas"></canvas>
      <div id="dragOverlay">Перетащите сюда фото, видео или шрифт<br>Не загружайте папки!</div>
    </div>

    <div class="tools" id="toolsPanel">
      <button id="hideToolsButton"><b>УБРАТЬ МЕНЮ ИНСТРУМЕНТОВ</b></button>
      <button id="shareTelegramBtn"><b>ПОДЕЛИТЬСЯ В TELEGRAM</b></button>
      <button 
        onclick="window.location.href = 'main.html'" 
        style="padding: 2.5vw 3vw; font-size: 4vw;"
      >
        ВЕРНУТЬСЯ В ГЛАВНОЕ МЕНЮ
      </button>

      <label for="bgColor"><b>Цвет фона:</b></label>
      <input type="color" id="bgColor" value="#800080" />

      <label for="textColor"><b>Цвет текста:</b></label>
      <input type="color" id="textColor" value="#000000" />

      <label for="borderColor"><b>Цвет границы:</b></label>
      <input type="color" id="borderColor" value="#000000" />

      <label for="borderWidth"><b>Толщина границы:</b></label>
      <input type="range" id="borderWidth" min="0" max="20" value="0" />

      <label for="text"><b>Текст на аватарке: <span id="charCount">0/10 000</span></b></label>
      <textarea id="text" placeholder="Ваш текст..." maxlength="10000"></textarea>

      <label for="fontSelect"><b>Шрифт текста:</b></label>
      <select id="fontSelect">
        <option value="upload">ЗАГРУЗИТЬ СВОЙ ШРИФТ</option>
        <option value="Arial" selected>Arial</option>
        <option value="Georgia">Georgia</option>
        <option value="Courier New">Courier New</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Verdana">Verdana</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Impact">Impact</option>
        <option value="Tahoma">Tahoma</option>
        <option value="Lucida Console">Lucida Console</option>
        <option value="Segoe UI">Segoe UI</option>
        <option value="Roboto">Roboto</option>
        <option value="Open Sans">Open Sans</option>
        <option value="Monospace">Monospace</option>
        <option value="Poppins">Poppins</option>
        <option value="Lobster">Lobster</option>
        <option value="Oswald">Oswald</option>
      </select>
      <input type="file" id="fontUpload" style="display:none" />
      <button id="fontUploadButton" style="display:none;"><b>ЗАГРУЗИТЬ СВОЙ ШРИФТ</b></button>

      <label for="textSize"><b>Размер текста:</b></label>
      <input type="range" id="textSize" min="10" max="100" value="50" />

      <label for="textShadow"><b>Тень текста:</b></label>
      <input type="range" id="textShadow" min="0" max="10" value="0" />

      <label for="shapeSelect"><b>Форма аватарки:</b></label>
      <select id="shapeSelect">
        <option value="circle">Круг</option>
        <option value="square">Квадрат</option>
        <option value="hexagon">Шестиугольник</option>
        <option value="star">Звезда</option>
        <option value="rectangle">Прямоугольник</option>
        <option value="oval">Овал</option>
        <option value="triangle">Треугольник</option>
        <option value="pentagon">Пятиугольник</option>
        <option value="heart">Сердце</option>
        <option value="rhombus">Ромб</option>
        <option value="cloud">Облако</option>
        <option value="arrowRight">Стрелка вправо</option>
        <option value="lightning">Молния</option>
        <option value="custom"><b>НАРИСОВАТЬ СВОЮ ФОРМУ</b></option>
      </select>

      <label for="bgType"><b>Тип фона:</b></label>
      <select id="bgType">
        <option value="other">Другое</option>
        <option value="telegram">Telegram</option>
      </select>

      <label for="imageUpload"><b>Загрузить фото:</b></label>
      <input type="file" id="imageUpload" accept="image/*" />
      <button id="removeImageBtn" class="btn-remove" style="display:none;"><b>УДАЛИТЬ ФОТО</b></button>

      <div id="videoSection" style="display:none;">
        <label for="videoUpload"><b>Загрузить видео (15с):</b></label>
        <input type="file" id="videoUpload" accept="video/*" />
        <button id="removeVideoBtn" class="btn-remove" style="display:none;"><b>УДАЛИТЬ ВИДЕО</b></button>
      </div>

      <div id="mediaSettings">
        <label for="alignCheckbox"><b>Выровнять фото/видео:</b></label>
        <input type="checkbox" id="alignCheckbox" />

        <label for="qualitySelect"><b>Качество фото/видео:</b></label>
        <select id="qualitySelect">
          <option value="original">Оригинал</option>
          <option value="144">144p</option>
          <option value="240">240p</option>
          <option value="360">360p</option>
          <option value="480">480p</option>
          <option value="720" disabled>720p60</option>
          <option value="1080" disabled>1080p60</option>
          <option value="1440" disabled>1440p60</option>
          <option value="2160" disabled>2k</option>
          <option value="4320" disabled>4k</option>
        </select>

        <label for="blurRange"><b>Размытие фото/видео:</b></label>
        <input type="range" id="blurRange" min="0" max="10" value="0" />
      </div>
    </div>
  </div>

  <script>
    const tg = window.Telegram.WebApp;

    /* ========= 0. Проверка ориентации устройства ========= */
    function checkOrientationWarning() {
      if (window.innerWidth > window.innerHeight && window.innerWidth <= 600) {
        orientationWarning.style.display = 'flex';
      } else {
        orientationWarning.style.display = 'none';
      }
    }
    const orientationWarning = document.getElementById('orientation-warning');
    const orientationOk = document.getElementById('orientation-ok');
    orientationOk.addEventListener('click', () => {
      orientationWarning.style.display = 'none';
    });
    window.addEventListener('load', checkOrientationWarning);
    window.addEventListener('resize', checkOrientationWarning);

    /* ========= 1. Модальное окно для ошибки видео ========= */
    const videoModal = document.getElementById('video-modal');
    const videoModalOk = document.getElementById('video-modal-ok');
    videoModalOk.addEventListener('click', () => {
      videoModal.style.display = 'none';
    });
    window.addEventListener('load', () => {
      videoModal.style.display = 'none';
    });

    /* ========= 2. Получение элементов ========= */
    const canvas = document.getElementById('avatarCanvas');
    const ctx = canvas.getContext('2d');
    const previewArea = document.getElementById('previewArea');
    const dragOverlay = document.getElementById('dragOverlay');
    const toolsPanel = document.getElementById('toolsPanel');
    const openToolsButton = document.getElementById('openToolsButton');
    const shareTelegramBtn = document.getElementById('shareTelegramBtn');

    const bgColorInput = document.getElementById('bgColor');
    const textColorInput = document.getElementById('textColor');
    const borderColorInput = document.getElementById('borderColor');
    const borderWidthInput = document.getElementById('borderWidth');
    const textInput = document.getElementById('text');
    const fontSelect = document.getElementById('fontSelect');
    const fontUpload = document.getElementById('fontUpload');
    const fontUploadButton = document.getElementById('fontUploadButton');
    const textSizeInput = document.getElementById('textSize');
    const textShadowInput = document.getElementById('textShadow');
    const shapeSelect = document.getElementById('shapeSelect');
    const bgTypeSelect = document.getElementById('bgType');
    const imageUpload = document.getElementById('imageUpload');
    const removeImageBtn = document.getElementById('removeImageBtn');
    const videoSection = document.getElementById('videoSection');
    const videoUpload = document.getElementById('videoUpload');
    const removeVideoBtn = document.getElementById('removeVideoBtn');
    const mediaSettings = document.getElementById('mediaSettings');
    const alignCheckbox = document.getElementById('alignCheckbox');
    const qualitySelect = document.getElementById('qualitySelect');
    const blurRange = document.getElementById('blurRange');

    /* ========= 3. Переменные для медиа и состояния ========= */
    let bgImage = null;
    let bgVideo = null;
    let videoAnimationId = null;
    let lastState = {};

    /* ========= 4. Переменные для пользовательской формы ========= */
    let drawnStrokes = [];
    let currentStroke = [];
    let customShapePoints = null;
    let eraserActive = false;
    let eraserRadius = 20;
    const eraserSizeRange = document.getElementById('eraserSizeRange');
    eraserSizeRange.addEventListener('input', () => {
      eraserRadius = parseInt(eraserSizeRange.value, 10);
    });

    /* ========= 5. Проверка поддержки FontFace ========= */
    window.addEventListener('load', () => {
      if (typeof FontFace === 'undefined') {
        const uploadOpt = document.querySelector('option[value="upload"]');
        uploadOpt.disabled = true;
        uploadOpt.textContent = 'ЗАГРУЗИТЬ ШРИФТ (Не доступно)';
      }
    });

    /* ========= 6. Обработка показа/скрытия панели инструментов ========= */
    hideToolsButton.addEventListener('click', () => {
      toolsPanel.style.display = 'none';
      openToolsButton.style.display = 'block';
      if (localStorage.getItem('created_profiles')) {
        localStorage.setItem('created_profiles', String(Number(localStorage.getItem('created_profiles')) + 1));
      } else {
        localStorage.setItem('created_profiles', '1');
      }
    });
    openToolsButton.addEventListener('click', () => {
      toolsPanel.style.display = 'block';
      openToolsButton.style.display = 'none';
    });

    /* ========= 7. Telegram Sharing ========= */
    shareTelegramBtn.addEventListener('click', () => {
      if (bgVideo) {
        alert('Видео-аватарки нельзя отправить в Telegram. Пожалуйста, используйте статическое изображение.');
        return;
      }
      const caption = textInput.value.slice(0, 200) || 'Моя аватарка'; // Limit caption to 200 chars
      const shareCanvas = document.createElement('canvas');
      const shareSize = 128; // Reduced size for Telegram
      shareCanvas.width = shareSize;
      shareCanvas.height = shareSize;
      const shareCtx = shareCanvas.getContext('2d');
      
      // Redraw avatar on smaller canvas
      shareCtx.save();
      applyShapeClip(shareCtx, shareSize, shapeSelect.value);
      shareCtx.fillStyle = bgColorInput.value;
      shareCtx.fillRect(0, 0, shareSize, shareSize);
      if (bgImage) {
        drawMedia(bgImage, shareCtx, shareSize);
      }
      shareCtx.restore();

      const bw = +borderWidthInput.value * (shareSize / canvas.width);
      if (bw > 0) {
        shareCtx.save();
        shareCtx.beginPath();
        if (shapeSelect.value === "circle") {
          shareCtx.arc(shareSize/2, shareSize/2, shareSize/2 - bw/2, 0, Math.PI*2);
        } else if (shapeSelect.value === "square" || shapeSelect.value === "rectangle") {
          shareCtx.rect(bw/2, bw/2, shareSize - bw, shareSize - bw);
        } else {
          applyShapeClip(shareCtx, shareSize, shapeSelect.value);
        }
        shareCtx.strokeStyle = borderColorInput.value;
        shareCtx.lineWidth = bw;
        shareCtx.stroke();
        shareCtx.restore();
      }

      const txt = textInput.value.slice(0, 200); // Limit text for drawing
      if (txt.trim() !== "") {
        shareCtx.save();
        const lines = txt.split("\n");
        shareCtx.font = `${textSizeInput.value * (shareSize / canvas.width)}px ${fontSelect.value}`;
        shareCtx.fillStyle = textColorInput.value;
        shareCtx.textAlign = 'center';
        shareCtx.textBaseline = 'middle';
        shareCtx.shadowColor = '#000';
        shareCtx.shadowBlur = +textShadowInput.value * (shareSize / canvas.width);
        const lineHeight = textSizeInput.value * 1.2 * (shareSize / canvas.width);
        const totalHeight = lineHeight * lines.length;
        lines.forEach((line, i) => {
          shareCtx.fillText(line, shareSize/2, shareSize/2 - totalHeight/2 + lineHeight/2 + i * lineHeight);
        });
        shareCtx.restore();
      }

      const dataUrl = shareCanvas.toDataURL('image/jpeg', 0.5); // Lower quality
      const data = JSON.stringify({ photo: dataUrl, text: caption });
      if (data.length > 64000) {
        alert('Ошибка: Изображение слишком большое для отправки в Telegram. Попробуйте уменьшить текст, убрать изображение или использовать более простую форму.');
        // Fallback: Offer to download the image
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'avatar.jpg';
        link.click();
        return;
      }
      try {
        tg.sendData(data);
      } catch (e) {
        alert(`Ошибка отправки в Telegram: ${e.message || 'Данные слишком большие. Попробуйте уменьшить текст или использовать более простое изображение.'}`);
      }
    });

    /* ========= 8. Функция отрисовки аватарки ========= */
    function drawAvatar() {
      const currentState = {
        bgColor: bgColorInput.value,
        textColor: textColorInput.value,
        borderColor: borderColorInput.value,
        borderWidth: borderWidthInput.value,
        text: textInput.value,
        font: fontSelect.value,
        textSize: textSizeInput.value,
        textShadow: textShadowInput.value,
        shape: shapeSelect.value,
        bgType: bgTypeSelect.value,
        align: alignCheckbox.checked,
        quality: qualitySelect.value,
        blur: blurRange.value,
        hasImage: !!bgImage,
        hasVideo: !!bgVideo,
      };
      if (JSON.stringify(currentState) === JSON.stringify(lastState)) return;
      lastState = currentState;

      requestAnimationFrame(() => {
        const isMobile = window.innerWidth <= 600;
        const size = Math.min(previewArea.clientWidth, previewArea.clientHeight, isMobile ? 512 : 1024);
        canvas.width = size;
        canvas.height = size;
        ctx.clearRect(0, 0, size, size);

        ctx.save();
        applyShapeClip(ctx, size, shapeSelect.value);
        ctx.fillStyle = bgColorInput.value;
        ctx.fillRect(0, 0, size, size);

        if (bgVideo) {
          drawMedia(bgVideo, ctx, size);
        } else if (bgImage) {
          drawMedia(bgImage, ctx, size);
        }
        ctx.restore();

        const bw = +borderWidthInput.value;
        if (bw > 0) {
          ctx.save();
          ctx.beginPath();
          if (shapeSelect.value === "circle") {
            ctx.arc(size/2, size/2, size/2 - bw/2, 0, Math.PI*2);
          } else if (shapeSelect.value === "square" || shapeSelect.value === "rectangle") {
            ctx.rect(bw/2, bw/2, size - bw, size - bw);
          } else {
            applyShapeClip(ctx, size, shapeSelect.value);
          }
          ctx.strokeStyle = borderColorInput.value;
          ctx.lineWidth = bw;
          ctx.stroke();
          ctx.restore();
        }

        const txt = textInput.value;
        if (txt.trim() !== "") {
          ctx.save();
          const lines = txt.split("\n");
          ctx.font = `${textSizeInput.value}px ${fontSelect.value}`;
          ctx.fillStyle = textColorInput.value;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = '#000';
          ctx.shadowBlur = +textShadowInput.value;
          const lineHeight = textSizeInput.value * 1.2;
          const totalHeight = lineHeight * lines.length;
          lines.forEach((line, i) => {
            ctx.fillText(line, size/2, size/2 - totalHeight/2 + lineHeight/2 + i * lineHeight);
          });
          ctx.restore();
        }
      });
    }

    /* ========= 9. Функция отрисовки медиа ========= */
    function drawMedia(media, context = ctx, size = canvas.width) {
      const qualityVal = qualitySelect.value;
      const align = alignCheckbox.checked;
      const blurVal = blurRange.value;

      let mediaWidth, mediaHeight;
      if (media.tagName === 'IMG') {
        mediaWidth = media.naturalWidth;
        mediaHeight = media.naturalHeight;
      } else {
        mediaWidth = media.videoWidth;
        mediaHeight = media.videoHeight;
      }
      let source = media;
      if (qualityVal !== "original" && !qualitySelect.options[qualitySelect.selectedIndex].disabled) {
        const targetHeight = parseInt(qualityVal, 10);
        const scale = targetHeight / mediaHeight;
        const targetWidth = Math.floor(mediaWidth * scale);
        const offCanvas = document.createElement('canvas');
        offCanvas.width = targetWidth;
        offCanvas.height = targetHeight;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(media, 0, 0, targetWidth, targetHeight);
        source = offCanvas;
        mediaWidth = targetWidth;
        mediaHeight = targetHeight;
      }
      if (blurVal > 0) {
        context.filter = `blur(${blurVal}px)`;
      }
      const cw = size;
      const ch = size;
      if (align) {
        const canvasRatio = cw / ch;
        const mediaRatio = mediaWidth / mediaHeight;
        let sx, sy, sWidth, sHeight;
        if (mediaRatio > canvasRatio) {
          sHeight = mediaHeight;
          sWidth = sHeight * canvasRatio;
          sx = (mediaWidth - sWidth) / 2;
          sy = 0;
        } else {
          sWidth = mediaWidth;
          sHeight = sWidth / canvasRatio;
          sx = 0;
          sy = (mediaHeight - sHeight) / 2;
        }
        context.drawImage(source, sx, sy, sWidth, sHeight, 0, 0, cw, ch);
      } else {
        context.drawImage(source, 0, 0, cw, ch);
      }
      context.filter = 'none';
    }

    /* ========= 10. Функция применения клипа по форме ========= */
    function applyShapeClip(ctx, size, shape) {
      ctx.beginPath();
      const center = size / 2;
      switch(shape) {
        case "circle":
          ctx.arc(center, center, center, 0, Math.PI * 2);
          break;
        case "square":
        case "rectangle":
          ctx.rect(0, 0, size, size);
          break;
        case "hexagon":
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "star":
          const outerRadius = center;
          const innerRadius = center * 0.5;
          for (let i = 0; i < 10; i++) {
            const angle = (Math.PI / 5) * i - Math.PI / 2;
            const r = i % 2 === 0 ? outerRadius : innerRadius;
            const x = center + r * Math.cos(angle);
            const y = center + r * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "oval":
          ctx.ellipse(center, center, center, center * 0.8, 0, 0, Math.PI * 2);
          break;
        case "triangle":
          ctx.moveTo(center, 0);
          ctx.lineTo(size, size);
          ctx.lineTo(0, size);
          ctx.closePath();
          break;
        case "pentagon":
          for (let i = 0; i < 5; i++) {
            const angle = Math.PI / 2 + (2 * Math.PI * i) / 5;
            const x = center + center * Math.cos(angle);
            const y = center + center * Math.sin(angle);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.closePath();
          break;
        case "heart":
          ctx.moveTo(center, size * 0.9);
          ctx.bezierCurveTo(
            center + size * 0.5, size * 0.6,
            center + size * 0.5, size * 0.2,
            center, size * 0.35
          );
          ctx.bezierCurveTo(
            center - size * 0.5, size * 0.2,
            center - size * 0.5, size * 0.6,
            center, size * 0.9
          );
          break;
        case "rhombus":
          ctx.moveTo(center, 0);
          ctx.lineTo(size, center);
          ctx.lineTo(center, size);
          ctx.lineTo(0, center);
          ctx.closePath();
          break;
        case "cloud":
          ctx.moveTo(center * 0.2, center);
          ctx.bezierCurveTo(
            center * 0.1, center * 0.6,
            center * 0.5, center * 0.6,
            center * 0.4, center * 0.3
          );
          ctx.bezierCurveTo(
            center * 0.6, center * 0.1,
            center * 1.4, center * 0.1,
            center * 1.6, center * 0.3
          );
          ctx.bezierCurveTo(
            center * 1.8, center * 0.4,
            center * 1.8, center,
            center * 1.6, center
          );
          ctx.bezierCurveTo(
            center * 1.4, center * 1.3,
            center * 0.6, center * 1.3,
            center * 0.4, center
          );
          ctx.closePath();
          break;
        case "arrowRight":
          ctx.moveTo(0, center * 0.5);
          ctx.lineTo(center, center * 0.5);
          ctx.lineTo(center, 0);
          ctx.lineTo(size, center);
          ctx.lineTo(center, size);
          ctx.lineTo(center, center * 1.5);
          ctx.lineTo(0, center * 1.5);
          ctx.closePath();
          break;
        case "lightning":
          ctx.moveTo(center * 0.3, 0);
          ctx.lineTo(center * 0.7, 0);
          ctx.lineTo(center * 0.4, center * 0.6);
          ctx.lineTo(center * 0.8, center * 0.6);
          ctx.lineTo(center * 0.2, size);
          ctx.lineTo(center * 0.6, center * 0.6);
          ctx.lineTo(center * 0.3, center * 0.6);
          ctx.closePath();
          break;
        case "custom":
          if (customShapePoints && customShapePoints.length > 0) {
            const path = new Path2D();
            path.moveTo(customShapePoints[0][0] * size, customShapePoints[0][1] * size);
            for (let i = 1; i < customShapePoints.length; i++) {
              path.lineTo(customShapePoints[i][0] * size, customShapePoints[i][1] * size);
            }
            path.closePath();
            ctx.clip(path);
            return;
          } else {
            ctx.arc(center, center, center, 0, Math.PI * 2);
          }
          break;
        default:
          ctx.rect(0, 0, size, size);
          break;
      }
      ctx.clip();
    }

    /* ========= 11. Обновление видимости блока загрузки видео ========= */
    function updateToolsVisibility() {
      if (bgTypeSelect.value === 'telegram') {
        videoSection.style.display = 'block';
      } else {
        videoSection.style.display = 'none';
        bgVideo = null;
        removeVideoBtn.style.display = 'none';
        stopVideoAnimation();
      }
      drawAvatar();
    }

    /* ========= 12. Обновление видимости mediaSettings ========= */
    function updateMediaSettingsVisibility() {
      if (bgImage || bgVideo) {
        mediaSettings.style.display = 'block';
        updateQualityOptions();
      } else {
        mediaSettings.style.display = 'none';
      }
      drawAvatar();
    }
    function updateQualityOptions() {
      const options = qualitySelect.options;
      let mediaHeight = 0;
      if (bgImage) {
        mediaHeight = bgImage.naturalHeight;
      } else if (bgVideo) {
        mediaHeight = bgVideo.videoHeight;
      }
      for (let i = 0; i < options.length; i++) {
        const opt = options[i];
        if (opt.value === "original") {
          opt.disabled = false;
        } else {
          const targetHeight = parseInt(opt.value);
          opt.disabled = (targetHeight > mediaHeight);
        }
      }
    }

    /* ========= 13. Загрузка фото ========= */
    imageUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      e.target.value = '';
      if (!file || !file.type.startsWith('image/')) return;
      bgVideo = null;
      removeVideoBtn.style.display = 'none';
      stopVideoAnimation();
      const img = new Image();
      img.onload = () => {
        bgImage = img;
        removeImageBtn.style.display = 'inline-block';
        updateMediaSettingsVisibility();
      };
      img.src = URL.createObjectURL(file);
    });
    removeImageBtn.addEventListener('click', () => {
      bgImage = null;
      imageUpload.value = '';
      removeImageBtn.style.display = 'none';
      updateMediaSettingsVisibility();
    });

    /* ========= 14. Загрузка видео ========= */
    videoUpload.addEventListener('change', (e) => {
      const files = e.target.files;
      if (!files || files.length === 0) return;
      const file = files[0];
      if (!file || !file.type.startsWith('video/')) return;
      bgImage = null;
      removeImageBtn.style.display = 'none';

      const vid = document.createElement('video');
      vid.muted = true;
      vid.playsInline = true;

      vid.addEventListener('loadedmetadata', () => {
        if (vid.duration > 15) {
          videoModal.style.display = 'flex';
          bgVideo = null;
          removeVideoBtn.style.display = 'none';
        } else {
          bgVideo = vid;
          removeVideoBtn.style.display = 'inline-block';
          vid.play();
          startVideoAnimation();
          updateMediaSettingsVisibility();
        }
        videoUpload.value = '';
      });

      vid.addEventListener('error', (err) => {
        console.error("Ошибка загрузки видео", err);
        videoUpload.value = '';
      });

      vid.src = URL.createObjectURL(file);
      vid.load();
    });
    removeVideoBtn.addEventListener('click', () => {
      bgVideo = null;
      videoUpload.value = '';
      removeVideoBtn.style.display = 'none';
      stopVideoAnimation();
      updateMediaSettingsVisibility();
    });
    function startVideoAnimation() {
      let lastFrameTime = 0;
      const maxFPS = 30;
      function updateFrame(timestamp) {
        if (timestamp - lastFrameTime < 1000 / maxFPS) {
          videoAnimationId = requestAnimationFrame(updateFrame);
          return;
        }
        lastFrameTime = timestamp;
        if (bgVideo && !bgVideo.paused && !bgVideo.ended) {
          drawAvatar();
          videoAnimationId = requestAnimationFrame(updateFrame);
        }
      }
      videoAnimationId = requestAnimationFrame(updateFrame);
    }
    function stopVideoAnimation() {
      if (videoAnimationId) {
        cancelAnimationFrame(videoAnimationId);
        videoAnimationId = null;
      }
    }

    /* ========= 15. Логика загрузки шрифта ========= */
    fontSelect.addEventListener('change', () => {
      if (fontSelect.value === "upload") {
        fontUploadButton.style.display = 'block';
        fontUpload.click();
        setTimeout(() => {
          fontSelect.value = "Arial";
          drawAvatar();
        }, 0);
      } else {
        fontUploadButton.style.display = 'none';
        drawAvatar();
      }
    });
    fontUploadButton.addEventListener('click', () => {
      fontUpload.click();
    });
    fontUpload.addEventListener('change', (e) => {
      let files = e.target.files;
      if (!files || files.length === 0) return;
      if (files.length > 1) {
        alert("Пожалуйста, загрузите один файл шрифта.");
        return;
      }
      let fontFile = null;
      for (let i = 0; i < files.length; i++) {
        if (files[i].name.match(/\.(ttf|otf)$/i)) {
          fontFile = files[i];
          break;
        }
      }
      if (!fontFile) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const fontData = ev.target.result;
        const fontName = "CustomFont_" + Date.now();
        const fontFace = new FontFace(fontName, fontData);
        fontFace.load().then((loadedFace) => {
          document.fonts.add(loadedFace);
          const option = document.createElement("option");
          option.value = fontName;
          option.textContent = fontName;
          fontSelect.appendChild(option);
          fontSelect.value = fontName;
          drawAvatar();
        }).catch(err => console.error("Ошибка загрузки шрифта:", err));
      };
      reader.readAsArrayBuffer(fontFile);
    });

    /* ========= 16. Перетаскивание медиа и файлов шрифта ========= */
    previewArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      previewArea.classList.add('dragover');
      dragOverlay.style.opacity = "1";
    });
    previewArea.addEventListener('dragleave', () => {
      previewArea.classList.remove('dragover');
      dragOverlay.style.opacity = "0";
    });
    previewArea.addEventListener('drop', (e) => {
      e.preventDefault();
      previewArea.classList.remove('dragover');
      dragOverlay.style.opacity = "0";
      const files = e.dataTransfer.files;
      if (!files || files.length === 0) return;
      if (/\.(ttf|otf)$/i.test(files[0].name)) {
        if (files.length > 1) {
          alert("Пожалуйста, перетащите один файл шрифта.");
          return;
        }
        const file = files[0];
        const reader = new FileReader();
        reader.onload = function(ev) {
          const fontData = ev.target.result;
          const fontName = "CustomFont_" + Date.now();
          const fontFace = new FontFace(fontName, fontData);
          fontFace.load().then((loadedFace) => {
            document.fonts.add(loadedFace);
            const option = document.createElement("option");
            option.value = fontName;
            option.textContent = fontName;
            fontSelect.appendChild(option);
            fontSelect.value = fontName;
            drawAvatar();
          }).catch(err => console.error("Ошибка загрузки шрифта:", err));
        };
        reader.readAsArrayBuffer(file);
        return;
      }
      if (files[0].type.startsWith('image/')) {
        const img = new Image();
        img.onload = () => {
          bgImage = img;
          removeImageBtn.style.display = 'inline-block';
          bgVideo = null;
          removeVideoBtn.style.display = 'none';
          stopVideoAnimation();
          updateMediaSettingsVisibility();
        };
        img.src = URL.createObjectURL(files[0]);
      } else if (files[0].type.startsWith('video/')) {
        const vid = document.createElement('video');
        vid.muted = true;
        vid.playsInline = true;
        vid.addEventListener('loadedmetadata', () => {
          if (vid.duration > 15) {
            videoModal.style.display = 'flex';
            bgVideo = null;
            removeVideoBtn.style.display = 'none';
          } else {
            bgVideo = vid;
            removeVideoBtn.style.display = 'inline-block';
            bgImage = null;
            removeImageBtn.style.display = 'none';
            vid.play();
            startVideoAnimation();
            updateMediaSettingsVisibility();
          }
        });
        vid.src = URL.createObjectURL(files[0]);
        vid.load();
      }
    });

    /* ========= 17. Изменения для пользовательской формы ========= */
    const customShapeModal = document.getElementById('customShapeModal');
    const customShapeCanvas = document.getElementById('customShapeCanvas');
    const customCtx = customShapeCanvas.getContext('2d');
    const saveCustomShapeBtn = document.getElementById('saveCustomShape');
    const cancelCustomShapeBtn = document.getElementById('cancelCustomShape');
    const eraseCustomShapeBtn = document.getElementById('toggleEraser');
    const resetCustomShapeBtn = document.getElementById('resetCustomShape');

    eraserActive = false;
    eraseCustomShapeBtn.addEventListener('click', () => {
      eraserActive = !eraserActive;
      document.getElementById('eraserSettings').style.display = eraserActive ? 'block' : 'none';
      eraseCustomShapeBtn.textContent = eraserActive ? "Ластик (активен)" : "Ластик";
      customShapeCanvas.style.cursor = eraserActive ? 'none' : 'default';
    });

    resetCustomShapeBtn.addEventListener('click', () => {
      drawnStrokes = [];
      currentStroke = [];
      customCtx.clearRect(0, 0, customShapeCanvas.width, customShapeCanvas.height);
    });

    function redrawCustomShapeCanvas() {
      customCtx.clearRect(0, 0, customShapeCanvas.width, customShapeCanvas.height);
      customCtx.beginPath();
      drawnStrokes.forEach(stroke => {
        if (stroke.length > 0) {
          customCtx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            customCtx.lineTo(stroke[i][0], stroke[i][1]);
          }
        }
      });
      if (currentStroke.length > 0) {
        customCtx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          customCtx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
      }
      customCtx.strokeStyle = 'black';
      customCtx.lineWidth = 2;
      customCtx.stroke();
    }

    function eraseAtPoint(x, y) {
      const newStrokes = [];
      drawnStrokes.forEach(stroke => {
        let subStroke = [];
        stroke.forEach(pt => {
          const dx = pt[0] - x;
          const dy = pt[1] - y;
          if (Math.sqrt(dx * dx + dy * dy) > eraserRadius) {
            subStroke.push(pt);
          } else {
            if (subStroke.length > 0) {
              newStrokes.push(subStroke);
              subStroke = [];
            }
          }
        });
        if (subStroke.length > 0) {
          newStrokes.push(subStroke);
        }
      });
      drawnStrokes = newStrokes;
      currentStroke = currentStroke.filter(pt => {
        const dx = pt[0] - x;
        const dy = pt[1] - y;
        return Math.sqrt(dx * dx + dy * dy) > eraserRadius;
      });
      redrawCustomShapeCanvas();
      drawEraserIndicator(x, y);
    }

    function drawEraserIndicator(x, y) {
      customCtx.save();
      customCtx.beginPath();
      customCtx.arc(x, y, eraserRadius, 0, 2 * Math.PI);
      customCtx.strokeStyle = 'red';
      customCtx.lineWidth = 1;
      customCtx.setLineDash([4, 2]);
      customCtx.stroke();
      customCtx.restore();
    }

    customShapeCanvas.addEventListener('mousedown', (e) => {
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke = [];
        currentStroke.push([x, y]);
      }
    });
    customShapeCanvas.addEventListener('mousemove', (e) => {
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (eraserActive) {
        if (e.buttons === 1) {
          eraseAtPoint(x, y);
        } else {
          redrawCustomShapeCanvas();
          drawEraserIndicator(x, y);
        }
      } else {
        if (e.buttons !== 1) return;
        currentStroke.push([x, y]);
        redrawCustomShapeCanvas();
      }
    });
    customShapeCanvas.addEventListener('mouseup', () => {
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });
    customShapeCanvas.addEventListener('mouseleave', () => {
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });

    customShapeCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke = [];
        currentStroke.push([x, y]);
      }
    });
    customShapeCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = customShapeCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      if (eraserActive) {
        eraseAtPoint(x, y);
      } else {
        currentStroke.push([x, y]);
        redrawCustomShapeCanvas();
      }
    });
    customShapeCanvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!eraserActive && currentStroke.length > 0) {
        drawnStrokes.push(currentStroke);
        currentStroke = [];
      }
    });

    saveCustomShapeBtn.addEventListener('click', () => {
      let combinedPoints = [];
      drawnStrokes.forEach(stroke => {
        combinedPoints = combinedPoints.concat(stroke);
      });
      if (combinedPoints.length > 1) {
        customShapePoints = combinedPoints.map(pt => [pt[0] / customShapeCanvas.width, pt[1] / customShapeCanvas.height]);
      }
      customShapeModal.style.display = 'none';
      drawAvatar();
    });
    cancelCustomShapeBtn.addEventListener('click', () => {
      customShapeModal.style.display = 'none';
      shapeSelect.value = 'circle';
      drawAvatar();
    });
    shapeSelect.addEventListener('change', () => {
      if (shapeSelect.value === 'custom') {
        customShapeModal.style.display = 'flex';
      }
      drawAvatar();
    });

    /* ========= 18. Привязка событий для остальных полей ========= */
    const allInputs = document.querySelectorAll('.tools input, .tools select, .tools textarea');
    allInputs.forEach(el => {
      el.addEventListener('input', drawAvatar);
      el.addEventListener('change', drawAvatar);
    });
    bgTypeSelect.addEventListener('change', updateToolsVisibility);

    function formatNumber(n) {
      return n.toLocaleString('ru-RU');
    }
    function updateCharCount() {
      document.getElementById('charCount').textContent = formatNumber(textInput.value.length) + "/" + formatNumber(10000);
    }
    textInput.addEventListener('input', updateCharCount);

    let cursorX = 0;
    let cursorY = 0;
    let isHoveringCanvas = false;
    canvas.addEventListener('mousemove', e => {
      isHoveringCanvas = true;
      const rect = canvas.getBoundingClientRect();
      cursorX = e.clientX - rect.left;
      cursorY = e.clientY - rect.top;
    });
    canvas.addEventListener('mouseleave', () => {
      isHoveringCanvas = false;
    });
    bgColorInput.addEventListener('input', () => {
      drawAvatar();
      if (isHoveringCanvas) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(cursorX, cursorY, 20, 0, 2 * Math.PI);
        ctx.fillStyle = bgColorInput.value;
        ctx.fill();
        ctx.restore();
      }
    });

    /* ========= 19. Инициализация ========= */
    updateToolsVisibility();
    updateMediaSettingsVisibility();
    drawAvatar();
  </script>
</body>
</html>